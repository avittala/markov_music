# Markov Music
Automatically generate music using Markov processes.
This project consists of two parts:
1. A flexible Music class capable of compiling note sequences to MIDI and playing this music.
2. A MarkovMusic class that uses these abilities to generate music via a simple Markov process.

# The Music class
Here's a quick look at sample usage of this class:
```
m = Music(120)
```
This generates a Music object with a tempo of 120 bpm. 
You can set a time signature (beats per measure, 4 = 4/4 time) and key signature (0 = C) by directly accessing the Music object.
```
m.ts = 4
m.key = 0
```
To add notes, use the `add_notes()` function. Remember that the `m.base_pitch` (default value is 60 or C5) is automatically added to any pitch.
```
ns = [(0,0,1),(1,0,1),(2,1,1)]
m.add_notes(ns)
````
Notes are specified as three-tuples of the pitch, offset from previous note (in beats), and duration (in beats). The above note sequence translates to a C5 quarter note, a C#5 quarter note, a quarter rest, and a D5 quarter note. You can call `add_notes()` as many times as you want, and each gets added as a separate line (which all start at the same time). 
```
m.compile()
m.write('out.midi')
m.play()
```
Compiling the Music object converts any note sequences into the list of play and sleep times we need for a MIDI file. Next, the write function converts this list into a correctly formatted MIDI file. You can open this file in any MIDI player. Alternatively, if you install [fluidsynth](https://www.fluidsynth.org/) and [pyfluidsynth](https://github.com/nwhitehead/pyfluidsynth), you can play the MIDI file directly from your computer! I pulled the sound font file Essential Keys-sfzBanks-v9.6.sf2 from [here](https://sites.google.com/site/soundfonts4u/)

# Generating music with Markov processes
The `markov_music.py` file include a subclass of the more general Music class and includes functions to automatically generate music. Sample usage of this class is provided in the make_music.ipynb Jupyter Notebook. The process typically involves three parts:
1. Generate a melody with the `make_melody` function. You must specify how many measures of melody you want to generate. All other arguments (time signature, key signature, instrument, allowed note durations, note subdivisions, and pitch range) are optional but strongly affect the music generated. Melodies are generated by serially chosing the next pitch and duration for each note; to bias the random choice, the program uses factors like pitch distance (melodies tend to have consecutive pitches right next to each other) or whether a pitch is in the key. These factors can be modified at the top of the `markov_music.py` file. 
2. Add harmony to complement the melody with the `add_harmony` function. This uses all previously generated music to create a new note sequence that complements the previous notes harmonically. Again, harmony notes are chosen serially with random choice biased by the factors at the top of the `markov_music.py` file. 
3. Add in repetitions to ensure higher continuity of the music. Repeats are added in recursively (i.e. if you put a repeat within a repeat, it gets repeated twice). 
Optionally, we can add in harmonies after we add repetitions. This helps break up any monotony due to the repetitions. 

# Best practices and future ideas
- Classical music vibes happen when most notes stay within the measures, there's high amounts of repetition, and we stay in key and harmonize strongly. Try also to reduce the number of varied durations notes can take (no more than three different durations)
- Jazzy vibes require complex rhythms, so add in more durations!
- I haven't added in rest generation yet, but the capability is there within the code. I'd have to treat rests as essentially another "pitch" that the notes could take and include maybe another factor called `is_rest_factor` to give (something like) the probability of a rest. It'd probably take me a few days to do it right, and since the results right now are pretty decent, I'm going to leave that for the future. 


